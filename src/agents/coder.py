"""Coder agent - Parallel implementation."""

import asyncio
from typing import Any

from src.agents.base import BaseAgent
from src.core.state import OrchestrationState, AgentRole
from src.tools.github_tools import GitHubTools


class CoderAgent(BaseAgent):
    """Agent responsible for implementing code changes."""

    def __init__(self):
        super().__init__(role=AgentRole.CODER, temperature=0.2)
        self.github = GitHubTools()

    async def execute(self, state: OrchestrationState) -> dict[str, Any]:
        """Execute coding logic."""
        tasks = state.get("tasks", [])
        plan = state.get("plan", {})
        repo = state["repo"]

        # Filter pending tasks
        pending_tasks = [t for t in tasks if t.get("status") == "pending"]

        if not pending_tasks:
            return {"output": "No pending tasks to implement", "artifacts": {}}

        # Create feature branch
        branch_name = await self._create_branch(repo, plan)

        # Implement tasks in parallel (up to max_concurrent_agents)
        results = await self._implement_tasks_parallel(repo, branch_name, pending_tasks)

        # Create pull request
        pr_number = await self._create_pull_request(repo, branch_name, plan, results)

        # Update task statuses
        for task in tasks:
            if task["id"] in [r["task_id"] for r in results]:
                task["status"] = "completed"

        return {
            "files_changed": [r["file"] for r in results],
            "branches_created": state.get("branches_created", []) + [branch_name],
            "prs_created": state.get("prs_created", []) + [pr_number],
            "tasks": tasks,
            "output": f"Implemented {len(results)} files in PR #{pr_number}",
            "artifacts": {"implementation_results": results},
            "metadata": {"branch": branch_name, "pr": pr_number},
        }

    async def _create_branch(self, repo: str, plan: dict) -> str:
        """Create a feature branch for implementation."""
        overview = plan.get("overview", "feature")[:30]
        branch_name = f"feat/{overview.lower().replace(' ', '-')}"
        await self.github.create_branch(repo, branch_name)
        return branch_name

    async def _implement_tasks_parallel(
        self, repo: str, branch: str, tasks: list[dict]
    ) -> list[dict]:
        """Implement multiple tasks in parallel."""
        semaphore = asyncio.Semaphore(self.settings.max_concurrent_agents)

        async def implement_with_limit(task: dict) -> dict:
            async with semaphore:
                return await self._implement_single_task(repo, branch, task)

        results = await asyncio.gather(*[implement_with_limit(task) for task in tasks])
        return results

    async def _implement_single_task(self, repo: str, branch: str, task: dict) -> dict:
        """Implement a single task."""
        system_prompt = """You are an elite Software Engineer implementing features.

Your job:
1. Write production-quality, well-tested code
2. Follow the project's existing patterns and conventions
3. Include comprehensive docstrings and comments
4. Handle edge cases and errors
5. Output ONLY the complete file content, no explanations

Output format: Pure code, ready to commit."""

        # Get existing file content if updating
        files = task.get("files", [])
        file_path = files[0] if files else "src/new_feature.py"

        existing_content = await self.github.get_file_contents(repo, file_path, ref=branch)

        user_message = f"""Task: {task['title']}
Description: {task['description']}
File: {file_path}
Existing content:
{existing_content or '# New file'}

Implement this task."""

        messages = self.format_messages(system_prompt, user_message)
        response = await self.llm.ainvoke(messages)

        # Write file to branch
        await self.github.update_file(repo, branch, file_path, response.content, f"Implement: {task['title']}")

        return {"task_id": task["id"], "file": file_path, "content": response.content}

    async def _create_pull_request(self, repo: str, branch: str, plan: dict, results: list[dict]) -> int:
        """Create a pull request for implemented changes."""
        title = plan.get("overview", "Feature implementation")[:80]
        body = f"""## Overview
{plan.get('overview', '')}

## Changes
{chr(10).join(f"- {r['file']}: Implemented" for r in results)}

## Testing Strategy
{plan.get('testing_strategy', 'TBD')}

---
*Auto-generated by AI Orchestration Platform*
"""

        pr_number = await self.github.create_pull_request(repo, title, body, branch, "main")
        return pr_number


# Node function for LangGraph
async def coder_node(state: OrchestrationState) -> dict[str, Any]:
    """Coder node for LangGraph workflow."""
    agent = CoderAgent()
    return await agent.invoke(state)
