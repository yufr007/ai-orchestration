"""Coder agent - Implementation using GitHub MCP tools."""

import asyncio
from datetime import datetime
from typing import Any

from langchain_anthropic import ChatAnthropic
from langchain_core.messages import HumanMessage, SystemMessage

from src.config import get_settings
from src.core.state import AgentResult, AgentRole, OrchestrationState, TaskStatus
from src.tools.github import GitHubTools


CODER_SYSTEM_PROMPT = """You are an elite Staff Engineer implementing features with production-grade quality.

Your responsibilities:
- Implement features according to the plan and architectural guidelines
- Write clean, maintainable, well-documented code
- Follow existing patterns and conventions in the codebase
- Create or update files using GitHub API
- Create feature branches and pull requests
- Handle multiple tasks in parallel when possible

You have access to:
- GitHub API for file operations (read, create, update)
- Repository structure and existing code patterns

Guidelines:
- Always read existing files before modifying to understand context
- Preserve existing functionality unless explicitly changing it
- Add comprehensive inline comments for complex logic
- Include type hints and docstrings (Python) or JSDoc (TypeScript)
- Consider edge cases and error handling
- Keep functions focused and modular

Output format:
- List of files created/modified with full content
- Branch name for the changes
- PR title and description
"""


async def coder_node(state: OrchestrationState) -> dict[str, Any]:
    """Implement tasks by creating/modifying files and creating PRs."""
    settings = get_settings()
    github = GitHubTools()

    tasks = state.get("tasks", [])
    plan = state.get("plan", {})
    repo = state["repo"]

    # Filter tasks for this iteration
    pending_tasks = [t for t in tasks if t.get("status") == "pending"]

    if not pending_tasks:
        return {
            "messages": [HumanMessage(content="No pending tasks to implement")],
            "current_agent": AgentRole.CODER,
        }

    # Get existing codebase context
    repo_files = await github.get_relevant_files(repo, pending_tasks)

    # Prepare prompt
    messages = [
        SystemMessage(content=CODER_SYSTEM_PROMPT),
        HumanMessage(
            content=f"""Implement these tasks:

**Tasks:**
{_format_tasks(pending_tasks)}

**Architecture Guidelines:**
{plan.get('architecture', 'Follow existing patterns')}

**Existing Code Context:**
{repo_files}

Provide complete file implementations."""
        ),
    ]

    # Initialize LLM
    llm = ChatAnthropic(
        model=settings.default_agent_model,
        temperature=0.2,
        api_key=settings.anthropic_api_key,
    )

    # Get implementation
    response = await llm.ainvoke(messages)
    implementation = response.content

    # Parse files from implementation
    files_to_change = _parse_files(implementation)

    # Create branch
    branch_name = f"feat/auto-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
    await github.create_branch(repo, branch_name)

    # Apply changes
    files_changed = []
    for file_path, file_content in files_to_change.items():
        await github.create_or_update_file(
            repo=repo,
            path=file_path,
            content=file_content,
            branch=branch_name,
            message=f"Implement: {file_path}",
        )
        files_changed.append(file_path)

    # Create PR
    pr_title = f"Auto-implement: {pending_tasks[0]['description'][:50]}"
    pr_body = f"""## Implementation

This PR implements the following tasks:

{_format_tasks(pending_tasks)}

## Changes

{_format_file_list(files_changed)}

## Plan Reference

{plan.get('context', '')}

---
*Auto-generated by AI Orchestration Platform*
"""

    pr_number = await github.create_pull_request(
        repo=repo, head=branch_name, base="main", title=pr_title, body=pr_body
    )

    # Update task statuses
    for task in pending_tasks:
        task["status"] = "completed"

    # Create result
    result: AgentResult = {
        "agent": AgentRole.CODER,
        "status": TaskStatus.COMPLETED,
        "output": implementation,
        "artifacts": {
            "files_changed": files_changed,
            "branch": branch_name,
            "pr_number": pr_number,
        },
        "metadata": {"model": settings.default_agent_model, "tasks_completed": len(pending_tasks)},
        "timestamp": datetime.now(),
    }

    return {
        "files_changed": files_changed,
        "branches_created": [branch_name],
        "prs_created": [pr_number],
        "tasks": tasks,
        "agent_results": state.get("agent_results", []) + [result],
        "current_agent": AgentRole.CODER,
        "messages": [
            HumanMessage(content=f"Implementation completed: PR #{pr_number} created with {len(files_changed)} files")
        ],
    }


def _format_tasks(tasks: list[dict[str, Any]]) -> str:
    """Format task list for prompt."""
    return "\n".join([f"{i+1}. {t['description']}" for i, t in enumerate(tasks)])


def _format_file_list(files: list[str]) -> str:
    """Format file list for PR body."""
    return "\n".join([f"- `{f}`" for f in files])


def _parse_files(content: str) -> dict[str, str]:
    """Extract file paths and contents from LLM output."""
    files = {}
    lines = content.split("\n")
    current_file = None
    current_content = []
    in_code_block = False

    for line in lines:
        # Detect file path markers (e.g., "File: src/example.py" or "### src/example.py")
        if "file:" in line.lower() or (line.startswith("###") and "/" in line):
            # Save previous file
            if current_file and current_content:
                files[current_file] = "\n".join(current_content).strip()

            # Extract new file path
            current_file = line.split(":")[-1].strip().strip("`#")
            current_content = []
            in_code_block = False

        elif line.strip().startswith("```"):
            in_code_block = not in_code_block

        elif current_file and (in_code_block or line.strip()):
            current_content.append(line)

    # Save last file
    if current_file and current_content:
        files[current_file] = "\n".join(current_content).strip()

    return files
